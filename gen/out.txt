/*$TET$header*/
/*$TET$*/

using namespace TEMPLET;

class my_engine{
public:
	my_engine(int argc, char *argv[]);
	void run();
	void map();
};

#pragma templet ~message1
struct message1{
	void send(actor*);
	bool access();

/*$TET$message1$$data*/
/*$TET$*/
};

#pragma templet ~message2=
struct message2{
	void send();
	bool access();

/*$TET$message2$$data*/
/*$TET$*/
};

#pragma templet ~message3$(submessage1!,submessage2?,submessage3?,-submessage4!)
struct message3{
	enum tag{TAG_submessage1,TAG_submessage2,TAG_submessage3,TAG_submessage4};

	struct submessage1{
/*$TET$message3$submessage1*/
/*$TET$*/
	} _submessage1;

	struct submessage2{
/*$TET$message3$submessage2*/
/*$TET$*/
	} _submessage2;

	struct submessage3{
/*$TET$message3$submessage3*/
/*$TET$*/
	} _submessage3;

	void send(tag);
	bool access(tag);

	void save(saver*s){
/*$TET$message3$$save*/
		//::save(s, &x, sizeof(x));
/*$TET$*/
	}

	void restore(restorer*r)
/*$TET$message3$$restore*/
		//::restore(r, &x, sizeof(x));
/*$TET$*/
	}
};

#pragma templet ~m(argsin2!,argcos2!,res?)
struct m{
	enum tag{TAG_argsin2,TAG_argcos2,TAG_res};

	struct argsin2{
/*$TET$m$argsin2*/
/*$TET$*/
	} _argsin2;

	struct argcos2{
/*$TET$m$argcos2*/
/*$TET$*/
	} _argcos2;

	struct res{
/*$TET$m$res*/
/*$TET$*/
	} _res;

	void send(tag);
	bool access(tag);
};

#pragma templet ~sm
struct sm{
	void send(actor*);
	bool access();

/*$TET$sm$$data*/
/*$TET$*/
};

#pragma templet ~ping$=
struct ping{
	void send();
	bool access();

	void save(saver*s){
/*$TET$ping$$save*/
		//::save(s, &x, sizeof(x));
/*$TET$*/
	}

	void restore(restorer*r)
/*$TET$ping$$restore*/
		//::restore(r, &x, sizeof(x));
/*$TET$*/
	}

/*$TET$ping$$data*/
/*$TET$*/
};

#pragma templet *actor1
struct actor1{
	actor1(my_engine&){
/*$TET$actor1$actor1*/
/*$TET$*/
	}

	void delay(double);
	void at(int);
	void stop();

	void recv_message1(message1&m){
/*$TET$actor1$recv_message1*/
/*$TET$*/
	}

	void recv_sm(sm&m){
/*$TET$actor1$recv_sm*/
/*$TET$*/
	}

/*$TET$actor1$$code&data*/
/*$TET$*/
};

#pragma templet *actor2+
struct actor2{
	actor2(my_engine&){
/*$TET$actor2$actor2*/
/*$TET$*/
	}

	void delay(double);
	void at(int);
	void stop();

	void start(){
/*$TET$actor2$start*/
/*$TET$*/
	}

	void recv_message1(message1&m){
/*$TET$actor2$recv_message1*/
/*$TET$*/
	}

	void recv_sm(sm&m){
/*$TET$actor2$recv_sm*/
/*$TET$*/
	}

/*$TET$actor2$$code&data*/
/*$TET$*/
};

#pragma templet *actor3$(?,port1?message2,port3!message4)+
struct actor3{
	actor3(my_engine&){
/*$TET$actor3$actor3*/
/*$TET$*/
	}

	void delay(double);
	void at(int);
	void stop();

	void start(){
/*$TET$actor3$start*/
/*$TET$*/
	}

	void recv_message1(message1&m){
/*$TET$actor3$recv_message1*/
/*$TET$*/
	}

	void recv_sm(sm&m){
/*$TET$actor3$recv_sm*/
/*$TET$*/
	}

	void port1(message2&m){
/*$TET$actor3$port1*/
/*$TET$*/
	}

	void port3(message4&m){
/*$TET$actor3$port3*/
/*$TET$*/
	}

	void save(saver*s){
/*$TET$actor3$$save*/
		//::save(s, &x, sizeof(x));
/*$TET$*/
	}

	void restore(restorer*r)
/*$TET$actor3$$restore*/
		//::restore(r, &x, sizeof(x));
/*$TET$*/
	}

/*$TET$actor3$$code&data*/
/*$TET$*/

	message4 _port3;
};

#pragma templet *master$(?,p1!m,p2?ping)+
struct master{
	master(my_engine&){
/*$TET$master$master*/
/*$TET$*/
	}

	void delay(double);
	void at(int);
	void stop();

	void start(){
/*$TET$master$start*/
/*$TET$*/
	}

	void recv_message1(message1&m){
/*$TET$master$recv_message1*/
/*$TET$*/
	}

	void recv_sm(sm&m){
/*$TET$master$recv_sm*/
/*$TET$*/
	}

	void p1(m&m){
/*$TET$master$p1*/
/*$TET$*/
	}

	void p2(ping&m){
/*$TET$master$p2*/
/*$TET$*/
	}

	void save(saver*s){
/*$TET$master$$save*/
		//::save(s, &x, sizeof(x));
/*$TET$*/
	}

	void restore(restorer*r)
/*$TET$master$$restore*/
		//::restore(r, &x, sizeof(x));
/*$TET$*/
	}

/*$TET$master$$code&data*/
/*$TET$*/

	m _p1;
};

/*$TET$footer*/
/*$TET$*/
